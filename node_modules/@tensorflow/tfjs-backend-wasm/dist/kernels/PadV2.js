/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { PadV2, util } from '@tensorflow/tfjs-core';
import { fill } from './Fill';
import { CppDType } from './types';
let wasmPadV2;
function setup(backend) {
    wasmPadV2 = backend.wasm.cwrap(PadV2, null /* void */, [
        'number',
        'array',
        'number',
        'number',
        'array',
        'array',
        'number',
        'number',
    ]);
}
function pad(args) {
    const { inputs: { x }, backend, attrs: { paddings, constantValue } } = args;
    const outShape = paddings.map((p, i) => p[0] /* beforePad */ + x.shape[i] + p[1] /* afterPad */);
    if (util.sizeFromShape(x.shape) === 0) {
        // Short-circuit the computation, since x doesn't have value, only
        // the shape is used to compute output shape to pad.
        return fill({
            backend,
            attrs: { shape: outShape, value: constantValue, dtype: x.dtype }
        });
    }
    const xId = backend.dataIdMap.get(x.dataId).id;
    const out = backend.makeOutput(outShape, x.dtype);
    const outTensorData = backend.dataIdMap.get(out.dataId);
    const outId = outTensorData.id;
    const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
    const prePaddingsFlat = paddings.map(padTuple => padTuple[0]);
    const postPaddingsFlat = paddings.map(padTuple => padTuple[1]);
    const prePaddingsBytes = new Uint8Array(new Int32Array(prePaddingsFlat).buffer);
    const postPaddingsBytes = new Uint8Array(new Int32Array(postPaddingsFlat).buffer);
    wasmPadV2(xId, xShapeBytes, x.shape.length, CppDType[x.dtype], prePaddingsBytes, postPaddingsBytes, constantValue, outId);
    return out;
}
export const padV2Config = {
    kernelName: PadV2,
    backendName: 'wasm',
    kernelFunc: pad,
    setupFunc: setup
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFkVjIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2FzbS9zcmMva2VybmVscy9QYWRWMi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQTJCLEtBQUssRUFBMkIsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFJckcsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUU1QixPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRWpDLElBQUksU0FHNkMsQ0FBQztBQUVsRCxTQUFTLEtBQUssQ0FBQyxPQUFvQjtJQUNqQyxTQUFTLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUU7UUFDckQsUUFBUTtRQUNSLE9BQU87UUFDUCxRQUFRO1FBQ1IsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO1FBQ1AsUUFBUTtRQUNSLFFBQVE7S0FDVCxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsU0FBUyxHQUFHLENBQ1IsSUFBb0U7SUFDdEUsTUFBTSxFQUFDLE1BQU0sRUFBRSxFQUFDLENBQUMsRUFBQyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBQyxRQUFRLEVBQUUsYUFBYSxFQUFDLEVBQUMsR0FBRyxJQUFJLENBQUM7SUFFdEUsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FDekIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBRXZFLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3JDLGtFQUFrRTtRQUNsRSxvREFBb0Q7UUFDcEQsT0FBTyxJQUFJLENBQUM7WUFDVixPQUFPO1lBQ1AsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFDO1NBQy9ELENBQUMsQ0FBQztLQUNKO0lBRUQsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUMvQyxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEQsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hELE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxFQUFFLENBQUM7SUFFL0IsTUFBTSxXQUFXLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRW5FLE1BQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5RCxNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvRCxNQUFNLGdCQUFnQixHQUNsQixJQUFJLFVBQVUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRCxNQUFNLGlCQUFpQixHQUNuQixJQUFJLFVBQVUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTVELFNBQVMsQ0FDTCxHQUFHLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsZ0JBQWdCLEVBQ3JFLGlCQUFpQixFQUFFLGFBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM3QyxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQWlCO0lBQ3ZDLFVBQVUsRUFBRSxLQUFLO0lBQ2pCLFdBQVcsRUFBRSxNQUFNO0lBQ25CLFVBQVUsRUFBRSxHQUF1QjtJQUNuQyxTQUFTLEVBQUUsS0FBSztDQUNqQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0tlcm5lbENvbmZpZywgS2VybmVsRnVuYywgUGFkVjIsIFBhZFYyQXR0cnMsIFBhZFYySW5wdXRzLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge0JhY2tlbmRXYXNtfSBmcm9tICcuLi9iYWNrZW5kX3dhc20nO1xuXG5pbXBvcnQge2ZpbGx9IGZyb20gJy4vRmlsbCc7XG5cbmltcG9ydCB7Q3BwRFR5cGV9IGZyb20gJy4vdHlwZXMnO1xuXG5sZXQgd2FzbVBhZFYyOiAoXG4gICAgeElkOiBudW1iZXIsIHhTaGFwZUJ5dGVzOiBVaW50OEFycmF5LCB4U2hhcGVMZW5ndGg6IG51bWJlciwgeER0eXBlOiBudW1iZXIsXG4gICAgcHJlUGFkZGluZ3NCeXRlczogVWludDhBcnJheSwgcG9zdFBhZGRpbmdzQnl0ZXM6IFVpbnQ4QXJyYXksXG4gICAgY29uc3RhbnRWYWx1ZTogbnVtYmVyLCBvdXRJZDogbnVtYmVyKSA9PiB2b2lkO1xuXG5mdW5jdGlvbiBzZXR1cChiYWNrZW5kOiBCYWNrZW5kV2FzbSkge1xuICB3YXNtUGFkVjIgPSBiYWNrZW5kLndhc20uY3dyYXAoUGFkVjIsIG51bGwgLyogdm9pZCAqLywgW1xuICAgICdudW1iZXInLCAgLy8geElkXG4gICAgJ2FycmF5JywgICAvLyB4LnNoYXBlXG4gICAgJ251bWJlcicsICAvLyB4LnNoYXBlLmxlbmd0aFxuICAgICdudW1iZXInLCAgLy8geC5kdHlwZVxuICAgICdhcnJheScsICAgLy8gcHJlLXBhZGRpbmdzXG4gICAgJ2FycmF5JywgICAvLyBwb3N0LXBhZGRpbmdzXG4gICAgJ251bWJlcicsICAvLyBjb25zdGFudFZhbHVlXG4gICAgJ251bWJlcicsICAvLyBvdXRJZFxuICBdKTtcbn1cblxuZnVuY3Rpb24gcGFkKFxuICAgIGFyZ3M6IHtpbnB1dHM6IFBhZFYySW5wdXRzLCBiYWNrZW5kOiBCYWNrZW5kV2FzbSwgYXR0cnM6IFBhZFYyQXR0cnN9KSB7XG4gIGNvbnN0IHtpbnB1dHM6IHt4fSwgYmFja2VuZCwgYXR0cnM6IHtwYWRkaW5ncywgY29uc3RhbnRWYWx1ZX19ID0gYXJncztcblxuICBjb25zdCBvdXRTaGFwZSA9IHBhZGRpbmdzLm1hcChcbiAgICAgIChwLCBpKSA9PiBwWzBdIC8qIGJlZm9yZVBhZCAqLyArIHguc2hhcGVbaV0gKyBwWzFdIC8qIGFmdGVyUGFkICovKTtcblxuICBpZiAodXRpbC5zaXplRnJvbVNoYXBlKHguc2hhcGUpID09PSAwKSB7XG4gICAgLy8gU2hvcnQtY2lyY3VpdCB0aGUgY29tcHV0YXRpb24sIHNpbmNlIHggZG9lc24ndCBoYXZlIHZhbHVlLCBvbmx5XG4gICAgLy8gdGhlIHNoYXBlIGlzIHVzZWQgdG8gY29tcHV0ZSBvdXRwdXQgc2hhcGUgdG8gcGFkLlxuICAgIHJldHVybiBmaWxsKHtcbiAgICAgIGJhY2tlbmQsXG4gICAgICBhdHRyczoge3NoYXBlOiBvdXRTaGFwZSwgdmFsdWU6IGNvbnN0YW50VmFsdWUsIGR0eXBlOiB4LmR0eXBlfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgeElkID0gYmFja2VuZC5kYXRhSWRNYXAuZ2V0KHguZGF0YUlkKS5pZDtcbiAgY29uc3Qgb3V0ID0gYmFja2VuZC5tYWtlT3V0cHV0KG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgY29uc3Qgb3V0VGVuc29yRGF0YSA9IGJhY2tlbmQuZGF0YUlkTWFwLmdldChvdXQuZGF0YUlkKTtcbiAgY29uc3Qgb3V0SWQgPSBvdXRUZW5zb3JEYXRhLmlkO1xuXG4gIGNvbnN0IHhTaGFwZUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoeC5zaGFwZSkuYnVmZmVyKTtcblxuICBjb25zdCBwcmVQYWRkaW5nc0ZsYXQgPSBwYWRkaW5ncy5tYXAocGFkVHVwbGUgPT4gcGFkVHVwbGVbMF0pO1xuICBjb25zdCBwb3N0UGFkZGluZ3NGbGF0ID0gcGFkZGluZ3MubWFwKHBhZFR1cGxlID0+IHBhZFR1cGxlWzFdKTtcbiAgY29uc3QgcHJlUGFkZGluZ3NCeXRlcyA9XG4gICAgICBuZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShwcmVQYWRkaW5nc0ZsYXQpLmJ1ZmZlcik7XG4gIGNvbnN0IHBvc3RQYWRkaW5nc0J5dGVzID1cbiAgICAgIG5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHBvc3RQYWRkaW5nc0ZsYXQpLmJ1ZmZlcik7XG5cbiAgd2FzbVBhZFYyKFxuICAgICAgeElkLCB4U2hhcGVCeXRlcywgeC5zaGFwZS5sZW5ndGgsIENwcERUeXBlW3guZHR5cGVdLCBwcmVQYWRkaW5nc0J5dGVzLFxuICAgICAgcG9zdFBhZGRpbmdzQnl0ZXMsIGNvbnN0YW50VmFsdWUsIG91dElkKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGNvbnN0IHBhZFYyQ29uZmlnOiBLZXJuZWxDb25maWcgPSB7XG4gIGtlcm5lbE5hbWU6IFBhZFYyLFxuICBiYWNrZW5kTmFtZTogJ3dhc20nLFxuICBrZXJuZWxGdW5jOiBwYWQgYXMge30gYXMgS2VybmVsRnVuYyxcbiAgc2V0dXBGdW5jOiBzZXR1cFxufTtcbiJdfQ==