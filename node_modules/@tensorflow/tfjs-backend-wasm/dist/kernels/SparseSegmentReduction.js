/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util } from '@tensorflow/tfjs-core';
import { CppDType } from './types';
let wasmSparseSegmentReduction;
export function setup(backend) {
    wasmSparseSegmentReduction =
        backend.wasm.cwrap('SparseSegmentReduction', null /*void*/, [
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
        ]);
}
export function sparseSegmentReduction(args, isMean) {
    const { backend, inputs } = args;
    const { data, indices, segmentIds } = inputs;
    const numIndices = indices.shape[0];
    const segmentIdsBack = backend.readSync(segmentIds.dataId, numIndices - 1, numIndices)[0];
    const lastSegmentIdPlusOne = numIndices > 0 ? segmentIdsBack + 1 : 0;
    const outputRows = lastSegmentIdPlusOne;
    if (outputRows < 0) {
        throw (new Error(backend_util
            .getSparseSegmentReductionNegativeSegmentIdsErrorMessage()));
    }
    const outputShape = data.shape.slice();
    outputShape[0] = outputRows;
    const dataId = backend.dataIdMap.get(data.dataId).id;
    const indicesId = backend.dataIdMap.get(indices.dataId).id;
    const segmentIdsId = backend.dataIdMap.get(segmentIds.dataId).id;
    const output = backend.makeOutput(outputShape, data.dtype);
    const outputId = backend.dataIdMap.get(output.dataId).id;
    const exceptionValues = backend.makeOutput([4], 'int32');
    const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;
    wasmSparseSegmentReduction(dataId, CppDType[data.dtype], data.shape[0], indicesId, segmentIdsId, outputId, exceptionValuesId, isMean, 0);
    const exceptionValuesArray = backend.readSync(exceptionValues.dataId);
    let exceptionMessage;
    switch (exceptionValuesArray[0]) {
        case 0: {
            exceptionMessage =
                backend_util
                    .getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
            break;
        }
        case 1: {
            exceptionMessage =
                backend_util
                    .getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
            break;
        }
        case 2:
            exceptionMessage =
                backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);
            break;
        case 3:
            exceptionMessage =
                backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2], exceptionValuesArray[3]);
            break;
        default:
            exceptionMessage = '';
    }
    backend.disposeData(exceptionValues.dataId);
    if (exceptionMessage) {
        backend.disposeData(output.dataId);
        throw new Error(exceptionMessage);
    }
    return output;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3BhcnNlU2VnbWVudFJlZHVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13YXNtL3NyYy9rZXJuZWxzL1NwYXJzZVNlZ21lbnRSZWR1Y3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLFlBQVksRUFBOEQsTUFBTSx1QkFBdUIsQ0FBQztBQUloSCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRWpDLElBQUksMEJBRzhDLENBQUM7QUFFbkQsTUFBTSxVQUFVLEtBQUssQ0FBQyxPQUFvQjtJQUN4QywwQkFBMEI7UUFDdEIsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUMxRCxRQUFRO1lBQ1IsUUFBUTtZQUNSLFFBQVE7WUFDUixRQUFRO1lBQ1IsUUFBUTtZQUNSLFFBQVE7WUFDUixRQUFRO1lBQ1IsUUFBUTtZQUNSLFFBQVE7U0FDVCxDQUFDLENBQUM7QUFDVCxDQUFDO0FBRUQsTUFBTSxVQUFVLHNCQUFzQixDQUNsQyxJQUdDLEVBQ0QsTUFBZTtJQUNqQixNQUFNLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBQyxHQUFHLElBQUksQ0FBQztJQUMvQixNQUFNLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUMsR0FBRyxNQUFNLENBQUM7SUFFM0MsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwQyxNQUFNLGNBQWMsR0FDZixPQUFPLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsVUFBVSxHQUFHLENBQUMsRUFBRSxVQUFVLENBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEIsTUFBTSxvQkFBb0IsR0FBRyxVQUFVLEdBQUcsQ0FBQyxDQUFD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QUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztLQUNuQztJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBTcGFyc2VTZWdtZW50TWVhbklucHV0cywgU3BhcnNlU2VnbWVudFN1bUlucHV0cywgVGVuc29ySW5mb30gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtCYWNrZW5kV2FzbX0gZnJvbSAnLi4vYmFja2VuZF93YXNtJztcblxuaW1wb3J0IHtDcHBEVHlwZX0gZnJvbSAnLi90eXBlcyc7XG5cbmxldCB3YXNtU3BhcnNlU2VnbWVudFJlZHVjdGlvbjogKFxuICAgIGRhdGFJZDogbnVtYmVyLCBkdHlwZTogbnVtYmVyLCBudW1Sb3c6IG51bWJlciwgaW5kaWNlc0lkOiBudW1iZXIsXG4gICAgc2VnbWVudElkc0lkOiBudW1iZXIsIG91dHB1dElkOiBudW1iZXIsIGV4Y2VwdGlvblZhbHVlc0lkOiBudW1iZXIsXG4gICAgaXNNZWFuOiBib29sZWFuLCBkZWZhdWx0VmFsdWU6IG51bWJlcikgPT4gdm9pZDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwKGJhY2tlbmQ6IEJhY2tlbmRXYXNtKTogdm9pZCB7XG4gIHdhc21TcGFyc2VTZWdtZW50UmVkdWN0aW9uID1cbiAgICAgIGJhY2tlbmQud2FzbS5jd3JhcCgnU3BhcnNlU2VnbWVudFJlZHVjdGlvbicsIG51bGwgLyp2b2lkKi8sIFtcbiAgICAgICAgJ251bWJlcicsICAvLyBkYXRhSWRcbiAgICAgICAgJ251bWJlcicsICAvLyBkdHlwZVxuICAgICAgICAnbnVtYmVyJywgIC8vIG51bVJvd1xuICAgICAgICAnbnVtYmVyJywgIC8vIGluZGljZXNJZFxuICAgICAgICAnbnVtYmVyJywgIC8vIHNlZ21lbnRJZHNJZFxuICAgICAgICAnbnVtYmVyJywgIC8vIG91dHB1dElkXG4gICAgICAgICdudW1iZXInLCAgLy8gZXhjZXB0aW9uVmFsdWVzSWQsXG4gICAgICAgICdudW1iZXInLCAgLy8gaXNNZWFuXG4gICAgICAgICdudW1iZXInLCAgLy8gZGVmYXVsdFZhbHVlXG4gICAgICBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwYXJzZVNlZ21lbnRSZWR1Y3Rpb24oXG4gICAgYXJnczoge1xuICAgICAgYmFja2VuZDogQmFja2VuZFdhc20sXG4gICAgICBpbnB1dHM6IFNwYXJzZVNlZ21lbnRTdW1JbnB1dHN8U3BhcnNlU2VnbWVudE1lYW5JbnB1dHMsXG4gICAgfSxcbiAgICBpc01lYW46IGJvb2xlYW4pOiBUZW5zb3JJbmZvIHtcbiAgY29uc3Qge2JhY2tlbmQsIGlucHV0c30gPSBhcmdzO1xuICBjb25zdCB7ZGF0YSwgaW5kaWNlcywgc2VnbWVudElkc30gPSBpbnB1dHM7XG5cbiAgY29uc3QgbnVtSW5kaWNlcyA9IGluZGljZXMuc2hhcGVbMF07XG4gIGNvbnN0IHNlZ21lbnRJZHNCYWNrID1cbiAgICAgIChiYWNrZW5kLnJlYWRTeW5jKHNlZ21lbnRJZHMuZGF0YUlkLCBudW1JbmRpY2VzIC0gMSwgbnVtSW5kaWNlcykgYXNcbiAgICAgICBJbnQzMkFycmF5KVswXTtcbiAgY29uc3QgbGFzdFNlZ21lbnRJZFBsdXNPbmUgPSBudW1JbmRpY2VzID4gMCA/IHNlZ21lbnRJZHNCYWNrICsgMSA6IDA7XG4gIGNvbnN0IG91dHB1dFJvd3MgPSBsYXN0U2VnbWVudElkUGx1c09uZTtcblxuICBpZiAob3V0cHV0Um93cyA8IDApIHtcbiAgICB0aHJvdyAobmV3IEVycm9yKFxuICAgICAgICBiYWNrZW5kX3V0aWxcbiAgICAgICAgICAgIC5nZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uTmVnYXRpdmVTZWdtZW50SWRzRXJyb3JNZXNzYWdlKCkpKTtcbiAgfVxuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZGF0YS5zaGFwZS5zbGljZSgpO1xuICBvdXRwdXRTaGFwZVswXSA9IG91dHB1dFJvd3M7XG5cbiAgY29uc3QgZGF0YUlkID0gYmFja2VuZC5kYXRhSWRNYXAuZ2V0KGRhdGEuZGF0YUlkKS5pZDtcbiAgY29uc3QgaW5kaWNlc0lkID0gYmFja2VuZC5kYXRhSWRNYXAuZ2V0KGluZGljZXMuZGF0YUlkKS5pZDtcbiAgY29uc3Qgc2VnbWVudElkc0lkID0gYmFja2VuZC5kYXRhSWRNYXAuZ2V0KHNlZ21lbnRJZHMuZGF0YUlkKS5pZDtcblxuICBjb25zdCBvdXRwdXQgPSBiYWNrZW5kLm1ha2VPdXRwdXQob3V0cHV0U2hhcGUsIGRhdGEuZHR5cGUpO1xuICBjb25zdCBvdXRwdXRJZCA9IGJhY2tlbmQuZGF0YUlkTWFwLmdldChvdXRwdXQuZGF0YUlkKS5pZDtcblxuICBjb25zdCBleGNlcHRpb25WYWx1ZXMgPSBiYWNrZW5kLm1ha2VPdXRwdXQoWzRdLCAnaW50MzInKTtcbiAgY29uc3QgZXhjZXB0aW9uVmFsdWVzSWQgPSBiYWNrZW5kLmRhdGFJZE1hcC5nZXQoZXhjZXB0aW9uVmFsdWVzLmRhdGFJZCkuaWQ7XG5cbiAgd2FzbVNwYXJzZVNlZ21lbnRSZWR1Y3Rpb24oXG4gICAgICBkYXRhSWQsIENwcERUeXBlW2RhdGEuZHR5cGVdLCBkYXRhLnNoYXBlWzBdLCBpbmRpY2VzSWQsIHNlZ21lbnRJZHNJZCxcbiAgICAgIG91dHB1dElkLCBleGNlcHRpb25WYWx1ZXNJZCwgaXNNZWFuLCAwKTtcblxuICBjb25zdCBleGNlcHRpb25WYWx1ZXNBcnJheSA9XG4gICAgICBiYWNrZW5kLnJlYWRTeW5jKGV4Y2VwdGlvblZhbHVlcy5kYXRhSWQpIGFzIEludDMyQXJyYXk7XG5cbiAgbGV0IGV4Y2VwdGlvbk1lc3NhZ2U6IHN0cmluZztcbiAgc3dpdGNoIChleGNlcHRpb25WYWx1ZXNBcnJheVswXSkge1xuICAgIGNhc2UgMDoge1xuICAgICAgZXhjZXB0aW9uTWVzc2FnZSA9XG4gICAgICAgICAgYmFja2VuZF91dGlsXG4gICAgICAgICAgICAgIC5nZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uTmVnYXRpdmVTZWdtZW50SWRzRXJyb3JNZXNzYWdlKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICBleGNlcHRpb25NZXNzYWdlID1cbiAgICAgICAgICBiYWNrZW5kX3V0aWxcbiAgICAgICAgICAgICAgLmdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25Ob25JbmNyZWFzaW5nU2VnbWVudElkc0Vycm9yTWVzc2FnZSgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMjpcbiAgICAgIGV4Y2VwdGlvbk1lc3NhZ2UgPVxuICAgICAgICAgIGJhY2tlbmRfdXRpbC5nZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uU2VnbWVudElkT3V0T2ZSYW5nZUVycm9yTWVzc2FnZShcbiAgICAgICAgICAgICAgZXhjZXB0aW9uVmFsdWVzQXJyYXlbMV0sIGV4Y2VwdGlvblZhbHVlc0FycmF5WzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGV4Y2VwdGlvbk1lc3NhZ2UgPVxuICAgICAgICAgIGJhY2tlbmRfdXRpbC5nZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uSW5kaWNlc091dE9mUmFuZ2VFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgIGV4Y2VwdGlvblZhbHVlc0FycmF5WzFdLCBleGNlcHRpb25WYWx1ZXNBcnJheVsyXSxcbiAgICAgICAgICAgICAgZXhjZXB0aW9uVmFsdWVzQXJyYXlbM10pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGV4Y2VwdGlvbk1lc3NhZ2UgPSAnJztcbiAgfVxuXG4gIGJhY2tlbmQuZGlzcG9zZURhdGEoZXhjZXB0aW9uVmFsdWVzLmRhdGFJZCk7XG4gIGlmIChleGNlcHRpb25NZXNzYWdlKSB7XG4gICAgYmFja2VuZC5kaXNwb3NlRGF0YShvdXRwdXQuZGF0YUlkKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXhjZXB0aW9uTWVzc2FnZSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuIl19