/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, SparseFillEmptyRows } from '@tensorflow/tfjs-core';
import { slice } from './Slice';
import { CppDType } from './types';
let wasmSparseFillEmptyRows;
export function setup(backend) {
    wasmSparseFillEmptyRows =
        backend.wasm.cwrap('SparseFillEmptyRows', 'number', [
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
        ]);
}
export function sparseFillEmptyRows(args) {
    const { backend, inputs } = args;
    const { indices, values, denseShape, defaultValue } = inputs;
    const indicesCount = indices.shape[0];
    const rank = indices.shape[1];
    const denseRows = backend.readSync(denseShape.dataId)[0];
    // Set output size to maximum possible and resize later (actual result
    // might be smaller).
    const maxOutputIndicesShape = [indicesCount + denseRows, rank];
    const indicesId = backend.dataIdMap.get(indices.dataId).id;
    const valuesId = backend.dataIdMap.get(values.dataId).id;
    const defaultValueId = backend.dataIdMap.get(defaultValue.dataId).id;
    const outputIndices = backend.makeOutput(maxOutputIndicesShape, indices.dtype);
    const outputIndicesId = backend.dataIdMap.get(outputIndices.dataId).id;
    const outputValues = backend.makeOutput(maxOutputIndicesShape.slice(0, 1), values.dtype);
    const outputValuesId = backend.dataIdMap.get(outputValues.dataId).id;
    const emptyRowIndicator = backend.makeOutput([denseRows], 'bool');
    const emptyRowIndicatorId = backend.dataIdMap.get(emptyRowIndicator.dataId).id;
    const reverseIndexMap = backend.makeOutput([indicesCount], indices.dtype);
    const reverseIndexMapId = backend.dataIdMap.get(reverseIndexMap.dataId).id;
    const exceptionValues = backend.makeOutput([4], 'int32');
    const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;
    const outputRows = wasmSparseFillEmptyRows(indicesId, valuesId, CppDType[values.dtype], indicesCount, denseRows, rank, defaultValueId, outputIndicesId, outputValuesId, emptyRowIndicatorId, reverseIndexMapId, exceptionValuesId);
    const exceptionValuesArray = backend.readSync(exceptionValues.dataId);
    let exceptionMessage;
    switch (exceptionValuesArray[0]) {
        case 1: {
            exceptionMessage =
                backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(exceptionValuesArray[1]);
            break;
        }
        case 2: {
            exceptionMessage =
                backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);
            break;
        }
        case 3:
            exceptionMessage =
                backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2], exceptionValuesArray[3]);
            break;
        default:
            exceptionMessage = '';
    }
    backend.disposeData(exceptionValues.dataId);
    if (exceptionMessage) {
        backend.disposeData(outputIndices.dataId);
        backend.disposeData(outputValues.dataId);
        backend.disposeData(emptyRowIndicator.dataId);
        backend.disposeData(reverseIndexMap.dataId);
        throw new Error(exceptionMessage);
    }
    let resizedIndices = outputIndices;
    let resizedValues = outputValues;
    // Overestimated output size.
    if (outputRows !== maxOutputIndicesShape[0]) {
        resizedIndices = slice({
            inputs: { x: outputIndices },
            attrs: { begin: 0, size: [outputRows, rank] },
            backend
        });
        resizedValues = slice({
            inputs: { x: outputValues },
            attrs: { begin: 0, size: outputRows },
            backend
        });
        backend.disposeData(outputIndices.dataId);
        backend.disposeData(outputValues.dataId);
    }
    return [resizedIndices, resizedValues, emptyRowIndicator, reverseIndexMap];
}
export const sparseFillEmptyRowsConfig = {
    kernelName: SparseFillEmptyRows,
    backendName: 'wasm',
    setupFunc: setup,
    kernelFunc: sparseFillEmptyRows
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3BhcnNlRmlsbEVtcHR5Um93cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13YXNtL3NyYy9rZXJuZWxzL1NwYXJzZUZpbGxFbXB0eVJvd3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLFlBQVksRUFBNEIsbUJBQW1CLEVBQXdDLE1BQU0sdUJBQXVCLENBQUM7QUFHekksT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUU5QixPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRWpDLElBQUksdUJBS29DLENBQUM7QUFFekMsTUFBTSxVQUFVLEtBQUssQ0FBQyxPQUFvQjtJQUN4Qyx1QkFBdUI7UUFDbkIsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMscUJBQXFCLEVBQUUsUUFBUSxFQUFFO1lBQ2xELFFBQVE7WUFDUixRQUFRO1lBQ1IsUUFBUTtZQUNSLFFBQVE7WUFDUixRQUFRO1lBQ1IsUUFBUTtZQUNSLFFBQVE7WUFDUixRQUFRO1lBQ1IsUUFBUTtZQUNSLFFBQVE7WUFDUixRQUFRO1lBQ1IsUUFBUTtTQUNULENBQUMsQ0FBQztBQUNULENBQUM7QUFFRCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsSUFHbkM7SUFDQyxNQUFNLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBQyxHQUFHLElBQUksQ0FBQztJQUMvQixNQUFNLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFDLEdBQUcsTUFBTSxDQUFDO0lBRTNELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEMsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMs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RSxFQUFDLENBQUMsRUFBRSxZQUFZLEVBQUM7WUFDekIsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFDO1lBQ25DLE9BQU87U0FDUixDQUFDLENBQUM7UUFDSCxPQUFPLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMxQyxPQUFPLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUMxQztJQUVELE9BQU8sQ0FBQyxjQUFjLEVBQUUsYUFBYSxFQUFFLGlCQUFpQixFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBQzdFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBaUI7SUFDckQsVUFBVSxFQUFFLG1CQUFtQjtJQUMvQixXQUFXLEVBQUUsTUFBTTtJQUNuQixTQUFTLEVBQUUsS0FBSztJQUNoQixVQUFVLEVBQUUsbUJBQXVDO0NBQ3BELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBLZXJuZWxDb25maWcsIEtlcm5lbEZ1bmMsIFNwYXJzZUZpbGxFbXB0eVJvd3MsIFNwYXJzZUZpbGxFbXB0eVJvd3NJbnB1dHMsIFRlbnNvckluZm99IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7QmFja2VuZFdhc219IGZyb20gJy4uL2JhY2tlbmRfd2FzbSc7XG5pbXBvcnQge3NsaWNlfSBmcm9tICcuL1NsaWNlJztcblxuaW1wb3J0IHtDcHBEVHlwZX0gZnJvbSAnLi90eXBlcyc7XG5cbmxldCB3YXNtU3BhcnNlRmlsbEVtcHR5Um93czogKFxuICAgIGluZGljZXNJZDogbnVtYmVyLCB2YWx1ZXNJZDogbnVtYmVyLCB2YWx1ZXNEVHlwZTogbnVtYmVyLFxuICAgIGluZGljZXNDb3VudDogbnVtYmVyLCBkZW5zZVJvd3M6IG51bWJlciwgcmFuazogbnVtYmVyLFxuICAgIGRlZmF1bHRWYWx1ZUlkOiBudW1iZXIsIG91dHB1dEluZGljZXNJZDogbnVtYmVyLCBvdXRwdXRWYWx1ZXNJZDogbnVtYmVyLFxuICAgIGVtcHR5Um93SW5kaWNhdG9ySWQ6IG51bWJlciwgcmV2ZXJzZUluZGV4TWFwSWQ6IG51bWJlcixcbiAgICBleGNlcHRpb25WYWx1ZXNJZDogbnVtYmVyKSA9PiBudW1iZXI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cChiYWNrZW5kOiBCYWNrZW5kV2FzbSk6IHZvaWQge1xuICB3YXNtU3BhcnNlRmlsbEVtcHR5Um93cyA9XG4gICAgICBiYWNrZW5kLndhc20uY3dyYXAoJ1NwYXJzZUZpbGxFbXB0eVJvd3MnLCAnbnVtYmVyJywgW1xuICAgICAgICAnbnVtYmVyJywgIC8vIGluZGljZXNJZFxuICAgICAgICAnbnVtYmVyJywgIC8vIHZhbHVlc0lkXG4gICAgICAgICdudW1iZXInLCAgLy8gdmFsdWVzRFR5cGVcbiAgICAgICAgJ251bWJlcicsICAvLyBpbmRpY2VzQ291bnRcbiAgICAgICAgJ251bWJlcicsICAvLyBkZW5zZVJvd3NcbiAgICAgICAgJ251bWJlcicsICAvLyByYW5rXG4gICAgICAgICdudW1iZXInLCAgLy8gZGVmYXVsdFZhbHVlSWRcbiAgICAgICAgJ251bWJlcicsICAvLyBvdXRwdXRJbmRpY2VzSWRcbiAgICAgICAgJ251bWJlcicsICAvLyBvdXRwdXRWYWx1ZXNJZFxuICAgICAgICAnbnVtYmVyJywgIC8vIGVtcHR5Um93SW5kaWNhdG9ySWRcbiAgICAgICAgJ251bWJlcicsICAvLyByZXZlcnNlSW5kZXhNYXBJZFxuICAgICAgICAnbnVtYmVyJywgIC8vIGV4Y2VwdGlvblZhbHVlc0lkXG4gICAgICBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwYXJzZUZpbGxFbXB0eVJvd3MoYXJnczoge1xuICBiYWNrZW5kOiBCYWNrZW5kV2FzbSxcbiAgaW5wdXRzOiBTcGFyc2VGaWxsRW1wdHlSb3dzSW5wdXRzLFxufSk6IFtUZW5zb3JJbmZvLCBUZW5zb3JJbmZvLCBUZW5zb3JJbmZvLCBUZW5zb3JJbmZvXSB7XG4gIGNvbnN0IHtiYWNrZW5kLCBpbnB1dHN9ID0gYXJncztcbiAgY29uc3Qge2luZGljZXMsIHZhbHVlcywgZGVuc2VTaGFwZSwgZGVmYXVsdFZhbHVlfSA9IGlucHV0cztcblxuICBjb25zdCBpbmRpY2VzQ291bnQgPSBpbmRpY2VzLnNoYXBlWzBdO1xuICBjb25zdCByYW5rID0gaW5kaWNlcy5zaGFwZVsxXTtcbiAgY29uc3QgZGVuc2VSb3dzID0gYmFja2VuZC5yZWFkU3luYyhkZW5zZVNoYXBlLmRhdGFJZClbMF0gYXMgbnVtYmVyO1xuXG4gIC8vIFNldCBvdXRwdXQgc2l6ZSB0byBtYXhpbXVtIHBvc3NpYmxlIGFuZCByZXNpemUgbGF0ZXIgKGFjdHVhbCByZXN1bHRcbiAgLy8gbWlnaHQgYmUgc21hbGxlcikuXG4gIGNvbnN0IG1heE91dHB1dEluZGljZXNTaGFwZSA9IFtpbmRpY2VzQ291bnQgKyBkZW5zZVJvd3MsIHJhbmtdO1xuXG4gIGNvbnN0IGluZGljZXNJZCA9IGJhY2tlbmQuZGF0YUlkTWFwLmdldChpbmRpY2VzLmRhdGFJZCkuaWQ7XG4gIGNvbnN0IHZhbHVlc0lkID0gYmFja2VuZC5kYXRhSWRNYXAuZ2V0KHZhbHVlcy5kYXRhSWQpLmlkO1xuICBjb25zdCBkZWZhdWx0VmFsdWVJZCA9IGJhY2tlbmQuZGF0YUlkTWFwLmdldChkZWZhdWx0VmFsdWUuZGF0YUlkKS5pZDtcblxuICBjb25zdCBvdXRwdXRJbmRpY2VzID1cbiAgICAgIGJhY2tlbmQubWFrZU91dHB1dChtYXhPdXRwdXRJbmRpY2VzU2hhcGUsIGluZGljZXMuZHR5cGUpO1xuICBjb25zdCBvdXRwdXRJbmRpY2VzSWQgPSBiYWNrZW5kLmRhdGFJZE1hcC5nZXQob3V0cHV0SW5kaWNlcy5kYXRhSWQpLmlkO1xuXG4gIGNvbnN0IG91dHB1dFZhbHVlcyA9XG4gICAgICBiYWNrZW5kLm1ha2VPdXRwdXQobWF4T3V0cHV0SW5kaWNlc1NoYXBlLnNsaWNlKDAsIDEpLCB2YWx1ZXMuZHR5cGUpO1xuICBjb25zdCBvdXRwdXRWYWx1ZXNJZCA9IGJhY2tlbmQuZGF0YUlkTWFwLmdldChvdXRwdXRWYWx1ZXMuZGF0YUlkKS5pZDtcblxuICBjb25zdCBlbXB0eVJvd0luZGljYXRvciA9IGJhY2tlbmQubWFrZU91dHB1dChbZGVuc2VSb3dzXSwgJ2Jvb2wnKTtcbiAgY29uc3QgZW1wdHlSb3dJbmRpY2F0b3JJZCA9XG4gICAgICBiYWNrZW5kLmRhdGFJZE1hcC5nZXQoZW1wdHlSb3dJbmRpY2F0b3IuZGF0YUlkKS5pZDtcblxuICBjb25zdCByZXZlcnNlSW5kZXhNYXAgPSBiYWNrZW5kLm1ha2VPdXRwdXQoW2luZGljZXNDb3VudF0sIGluZGljZXMuZHR5cGUpO1xuICBjb25zdCByZXZlcnNlSW5kZXhNYXBJZCA9IGJhY2tlbmQuZGF0YUlkTWFwLmdldChyZXZlcnNlSW5kZXhNYXAuZGF0YUlkKS5pZDtcblxuICBjb25zdCBleGNlcHRpb25WYWx1ZXMgPSBiYWNrZW5kLm1ha2VPdXRwdXQoWzRdLCAnaW50MzInKTtcbiAgY29uc3QgZXhjZXB0aW9uVmFsdWVzSWQgPSBiYWNrZW5kLmRhdGFJZE1hcC5nZXQoZXhjZXB0aW9uVmFsdWVzLmRhdGFJZCkuaWQ7XG5cbiAgY29uc3Qgb3V0cHV0Um93cyA9IHdhc21TcGFyc2VGaWxsRW1wdHlSb3dzKFxuICAgICAgaW5kaWNlc0lkLCB2YWx1ZXNJZCwgQ3BwRFR5cGVbdmFsdWVzLmR0eXBlXSwgaW5kaWNlc0NvdW50LCBkZW5zZVJvd3MsXG4gICAgICByYW5rLCBkZWZhdWx0VmFsdWVJZCwgb3V0cHV0SW5kaWNlc0lkLCBvdXRwdXRWYWx1ZXNJZCxcbiAgICAgIGVtcHR5Um93SW5kaWNhdG9ySWQsIHJldmVyc2VJbmRleE1hcElkLCBleGNlcHRpb25WYWx1ZXNJZCk7XG5cbiAgY29uc3QgZXhjZXB0aW9uVmFsdWVzQXJyYXkgPVxuICAgICAgYmFja2VuZC5yZWFkU3luYyhleGNlcHRpb25WYWx1ZXMuZGF0YUlkKSBhcyBJbnQzMkFycmF5O1xuXG4gIGxldCBleGNlcHRpb25NZXNzYWdlOiBzdHJpbmc7XG4gIHN3aXRjaCAoZXhjZXB0aW9uVmFsdWVzQXJyYXlbMF0pIHtcbiAgICBjYXNlIDE6IHtcbiAgICAgIGV4Y2VwdGlvbk1lc3NhZ2UgPVxuICAgICAgICAgIGJhY2tlbmRfdXRpbC5nZXRTcGFyc2VGaWxsRW1wdHlSb3dzSW5kaWNlc0RlbnNlU2hhcGVNaXNtYXRjaChcbiAgICAgICAgICAgICAgZXhjZXB0aW9uVmFsdWVzQXJyYXlbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgZXhjZXB0aW9uTWVzc2FnZSA9XG4gICAgICAgICAgYmFja2VuZF91dGlsLmdldFNwYXJzZUZpbGxFbXB0eVJvd3NOZWdhdGl2ZUluZGV4RXJyb3JNZXNzYWdlKFxuICAgICAgICAgICAgICBleGNlcHRpb25WYWx1ZXNBcnJheVsxXSwgZXhjZXB0aW9uVmFsdWVzQXJyYXlbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMzpcbiAgICAgIGV4Y2VwdGlvbk1lc3NhZ2UgPVxuICAgICAgICAgIGJhY2tlbmRfdXRpbC5nZXRTcGFyc2VGaWxsRW1wdHlSb3dzT3V0T2ZSYW5nZUluZGV4RXJyb3JNZXNzYWdlKFxuICAgICAgICAgICAgICBleGNlcHRpb25WYWx1ZXNBcnJheVsxXSwgZXhjZXB0aW9uVmFsdWVzQXJyYXlbMl0sXG4gICAgICAgICAgICAgIGV4Y2VwdGlvblZhbHVlc0FycmF5WzNdKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBleGNlcHRpb25NZXNzYWdlID0gJyc7XG4gIH1cblxuICBiYWNrZW5kLmRpc3Bvc2VEYXRhKGV4Y2VwdGlvblZhbHVlcy5kYXRhSWQpO1xuICBpZiAoZXhjZXB0aW9uTWVzc2FnZSkge1xuICAgIGJhY2tlbmQuZGlzcG9zZURhdGEob3V0cHV0SW5kaWNlcy5kYXRhSWQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZURhdGEob3V0cHV0VmFsdWVzLmRhdGFJZCk7XG4gICAgYmFja2VuZC5kaXNwb3NlRGF0YShlbXB0eVJvd0luZGljYXRvci5kYXRhSWQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZURhdGEocmV2ZXJzZUluZGV4TWFwLmRhdGFJZCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGV4Y2VwdGlvbk1lc3NhZ2UpO1xuICB9XG5cbiAgbGV0IHJlc2l6ZWRJbmRpY2VzID0gb3V0cHV0SW5kaWNlcztcbiAgbGV0IHJlc2l6ZWRWYWx1ZXMgPSBvdXRwdXRWYWx1ZXM7XG4gIC8vIE92ZXJlc3RpbWF0ZWQgb3V0cHV0IHNpemUuXG4gIGlmIChvdXRwdXRSb3dzICE9PSBtYXhPdXRwdXRJbmRpY2VzU2hhcGVbMF0pIHtcbiAgICByZXNpemVkSW5kaWNlcyA9IHNsaWNlKHtcbiAgICAgIGlucHV0czoge3g6IG91dHB1dEluZGljZXN9LFxuICAgICAgYXR0cnM6IHtiZWdpbjogMCwgc2l6ZTogW291dHB1dFJvd3MsIHJhbmtdfSxcbiAgICAgIGJhY2tlbmRcbiAgICB9KTtcbiAgICByZXNpemVkVmFsdWVzID0gc2xpY2Uoe1xuICAgICAgaW5wdXRzOiB7eDogb3V0cHV0VmFsdWVzfSxcbiAgICAgIGF0dHJzOiB7YmVnaW46IDAsIHNpemU6IG91dHB1dFJvd3N9LFxuICAgICAgYmFja2VuZFxuICAgIH0pO1xuICAgIGJhY2tlbmQuZGlzcG9zZURhdGEob3V0cHV0SW5kaWNlcy5kYXRhSWQpO1xuICAgIGJhY2tlbmQuZGlzcG9zZURhdGEob3V0cHV0VmFsdWVzLmRhdGFJZCk7XG4gIH1cblxuICByZXR1cm4gW3Jlc2l6ZWRJbmRpY2VzLCByZXNpemVkVmFsdWVzLCBlbXB0eVJvd0luZGljYXRvciwgcmV2ZXJzZUluZGV4TWFwXTtcbn1cblxuZXhwb3J0IGNvbnN0IHNwYXJzZUZpbGxFbXB0eVJvd3NDb25maWc6IEtlcm5lbENvbmZpZyA9IHtcbiAga2VybmVsTmFtZTogU3BhcnNlRmlsbEVtcHR5Um93cyxcbiAgYmFja2VuZE5hbWU6ICd3YXNtJyxcbiAgc2V0dXBGdW5jOiBzZXR1cCxcbiAga2VybmVsRnVuYzogc3BhcnNlRmlsbEVtcHR5Um93cyBhcyB7fSBhcyBLZXJuZWxGdW5jXG59O1xuIl19